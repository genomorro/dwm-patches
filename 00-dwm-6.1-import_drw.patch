From 7af4d439bdb5a2e40aca69446a3367bd71431c45 Mon Sep 17 00:00:00 2001
From: Markus Teich <markus.teich@stusta.mhn.de>
Date: Sun, 22 May 2016 20:33:56 +0000
Subject: import new drw from libsl and minor fixes.

- better scaling for occupied tag squares.
- draw statusline first to omitt some complicated calculations.
---
diff --git a/config.def.h b/config.def.h
index 7054c06..13ea4b9 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,20 +1,22 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const char *fonts[] = {
-	"monospace:size=10"
-};
-static const char dmenufont[]       = "monospace:size=10";
-static const char normbordercolor[] = "#444444";
-static const char normbgcolor[]     = "#222222";
-static const char normfgcolor[]     = "#bbbbbb";
-static const char selbordercolor[]  = "#005577";
-static const char selbgcolor[]      = "#005577";
-static const char selfgcolor[]      = "#eeeeee";
 static const unsigned int borderpx  = 1;        /* border pixel of windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
+static const char *fonts[]          = { "monospace:size=10" };
+static const char dmenufont[]       = "monospace:size=10";
+static const char col_gray1[]       = "#222222";
+static const char col_gray2[]       = "#444444";
+static const char col_gray3[]       = "#bbbbbb";
+static const char col_gray4[]       = "#eeeeee";
+static const char col_cyan[]        = "#005577";
+static const char *colors[][3]      = {
+	/* fg        bg         border   */
+	{ col_gray3, col_gray1, col_gray2}, /* normal */
+	{ col_gray4, col_cyan,  col_cyan }, /* selected */
+};
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
@@ -54,7 +56,7 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
 static Key keys[] = {
diff --git a/drw.c b/drw.c
index f49200b..987e53b 100644
--- a/drw.c
+++ b/drw.c
@@ -63,9 +63,8 @@ utf8decode(const char *c, long *u, size_t clen)
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
 {
-	Drw *drw;
+	Drw *drw = ecalloc(1, sizeof(Drw));
 
-	drw = ecalloc(1, sizeof(Drw));
 	drw->dpy = dpy;
 	drw->screen = screen;
 	drw->root = root;
@@ -73,7 +72,6 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
 	drw->h = h;
 	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
 	drw->gc = XCreateGC(dpy, root, 0, NULL);
-	drw->fontcount = 0;
 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
 
 	return drw;
@@ -82,6 +80,9 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
 void
 drw_resize(Drw *drw, unsigned int w, unsigned int h)
 {
+	if (!drw)
+		return;
+
 	drw->w = w;
 	drw->h = h;
 	if (drw->drawable)
@@ -92,44 +93,39 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
 void
 drw_free(Drw *drw)
 {
-	size_t i;
-
-	for (i = 0; i < drw->fontcount; i++)
-		drw_font_free(drw->fonts[i]);
 	XFreePixmap(drw->dpy, drw->drawable);
 	XFreeGC(drw->dpy, drw->gc);
 	free(drw);
 }
 
 /* This function is an implementation detail. Library users should use
- * drw_font_create instead.
+ * drw_fontset_create instead.
  */
 static Fnt *
-drw_font_xcreate(Drw *drw, const char *fontname, FcPattern *fontpattern)
+xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
 {
 	Fnt *font;
 	XftFont *xfont = NULL;
 	FcPattern *pattern = NULL;
 
 	if (fontname) {
-		/* Using the pattern found at font->xfont->pattern does not yield same
-		 * the same substitution results as using the pattern returned by
+		/* Using the pattern found at font->xfont->pattern does not yield the
+		 * same substitution results as using the pattern returned by
 		 * FcNameParse; using the latter results in the desired fallback
-		 * behaviour whereas the former just results in
-		 * missing-character-rectangles being drawn, at least with some fonts.
-		 */
+		 * behaviour whereas the former just results in missing-character
+		 * rectangles being drawn, at least with some fonts. */
 		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-			fprintf(stderr, "error, cannot load font: '%s'\n", fontname);
+			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
 			return NULL;
 		}
 		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-			fprintf(stderr, "error, cannot load font: '%s'\n", fontname);
+			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
 			XftFontClose(drw->dpy, xfont);
 			return NULL;
 		}
 	} else if (fontpattern) {
 		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-			fprintf(stderr, "error, cannot load font pattern.\n");
+			fprintf(stderr, "error, cannot load font from pattern.\n");
 			return NULL;
 		}
 	} else {
@@ -139,95 +135,115 @@ drw_font_xcreate(Drw *drw, const char *fontname, FcPattern *fontpattern)
 	font = ecalloc(1, sizeof(Fnt));
 	font->xfont = xfont;
 	font->pattern = pattern;
-	font->ascent = xfont->ascent;
-	font->descent = xfont->descent;
-	font->h = font->ascent + font->descent;
+	font->h = xfont->ascent + xfont->descent;
 	font->dpy = drw->dpy;
 
 	return font;
 }
 
-Fnt*
-drw_font_create(Drw *drw, const char *fontname)
+static void
+xfont_free(Fnt *font)
 {
-	return drw_font_xcreate(drw, fontname, NULL);
+	if (!font)
+		return;
+	if (font->pattern)
+		FcPatternDestroy(font->pattern);
+	XftFontClose(font->dpy, font->xfont);
+	free(font);
 }
 
-void
-drw_load_fonts(Drw* drw, const char *fonts[], size_t fontcount)
+Fnt*
+drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
 {
+	Fnt *cur, *ret = NULL;
 	size_t i;
-	Fnt *font;
 
-	for (i = 0; i < fontcount; i++) {
-		if (drw->fontcount >= DRW_FONT_CACHE_SIZE) {
-			die("font cache exhausted.\n");
-		} else if ((font = drw_font_xcreate(drw, fonts[i], NULL))) {
-			drw->fonts[drw->fontcount++] = font;
+	if (!drw || !fonts)
+		return NULL;
+
+	for (i = 1; i <= fontcount; i++) {
+		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
+			cur->next = ret;
+			ret = cur;
 		}
 	}
+	return (drw->fonts = ret);
 }
 
 void
-drw_font_free(Fnt *font)
+drw_fontset_free(Fnt *font)
 {
-	if (!font)
-		return;
-	if (font->pattern)
-		FcPatternDestroy(font->pattern);
-	XftFontClose(font->dpy, font->xfont);
-	free(font);
+	if (font) {
+		drw_fontset_free(font->next);
+		xfont_free(font);
+	}
 }
 
-Clr *
-drw_clr_create(Drw *drw, const char *clrname)
+void
+drw_clr_create(Drw *drw, XftColor *dest, const char *clrname)
 {
-	Clr *clr;
+	if (!drw || !dest || !clrname)
+		return;
 
-	clr = ecalloc(1, sizeof(Clr));
 	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
 	                       DefaultColormap(drw->dpy, drw->screen),
-	                       clrname, &clr->rgb))
+	                       clrname, dest))
 		die("error, cannot allocate color '%s'\n", clrname);
-	clr->pix = clr->rgb.pixel;
+}
+
+/* Wrapper to create color schemes. The caller has to call free(3) on the
+ * returned color scheme when done using it. */
+Scm
+drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+{
+	size_t i;
+	Scm ret;
+
+	/* need at least two colors for a scheme */
+	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
+		return NULL;
 
-	return clr;
+	for (i = 0; i < clrcount; i++)
+		drw_clr_create(drw, &ret[i], clrnames[i]);
+	return ret;
 }
 
 void
-drw_clr_free(Clr *clr)
+drw_setfontset(Drw *drw, Fnt *set)
 {
-	free(clr);
+	if (drw)
+		drw->fonts = set;
 }
 
 void
-drw_setscheme(Drw *drw, ClrScheme *scheme)
+drw_setscheme(Drw *drw, Scm scm)
 {
-	drw->scheme = scheme;
+	if (drw)
+		drw->scheme = scm;
 }
 
 void
-drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert)
+drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
-	if (!drw->scheme)
+	if (!drw || !drw->scheme)
 		return;
-	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme->bg->pix : drw->scheme->fg->pix);
+	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
 	if (filled)
-		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w + 1, h + 1);
-	else if (empty)
-		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+	else
+		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
 }
 
 int
-drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert)
+drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
 {
 	char buf[1024];
-	int tx, ty, th;
-	Extnts tex;
+	int ty;
+	unsigned int ew;
 	XftDraw *d = NULL;
-	Fnt *curfont, *nextfont;
+	Fnt *usedfont, *curfont, *nextfont;
 	size_t i, len;
-	int utf8strlen, utf8charlen, render;
+	int utf8strlen, utf8charlen, render = x || y || w || h;
 	long utf8codepoint = 0;
 	const char *utf8str;
 	FcCharSet *fccharset;
@@ -236,66 +252,67 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 	XftResult result;
 	int charexists = 0;
 
-	if (!drw->scheme || !drw->fontcount)
+	if (!drw || (render && !drw->scheme) || !text || !drw->fonts)
 		return 0;
 
-	if (!(render = x || y || w || h)) {
+	if (!render) {
 		w = ~w;
 	} else {
-		XSetForeground(drw->dpy, drw->gc, invert ?
-		               drw->scheme->fg->pix : drw->scheme->bg->pix);
+		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 		d = XftDrawCreate(drw->dpy, drw->drawable,
 		                  DefaultVisual(drw->dpy, drw->screen),
 		                  DefaultColormap(drw->dpy, drw->screen));
+		x += lpad;
+		w -= lpad;
 	}
 
-	curfont = drw->fonts[0];
+	usedfont = drw->fonts;
 	while (1) {
 		utf8strlen = 0;
 		utf8str = text;
 		nextfont = NULL;
 		while (*text) {
 			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
-			for (i = 0; i < drw->fontcount; i++) {
-				charexists = charexists || XftCharExists(drw->dpy, drw->fonts[i]->xfont, utf8codepoint);
+			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
+				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
 				if (charexists) {
-					if (drw->fonts[i] == curfont) {
+					if (curfont == usedfont) {
 						utf8strlen += utf8charlen;
 						text += utf8charlen;
 					} else {
-						nextfont = drw->fonts[i];
+						nextfont = curfont;
 					}
 					break;
 				}
 			}
 
-			if (!charexists || (nextfont && nextfont != curfont))
+			if (!charexists || nextfont)
 				break;
 			else
 				charexists = 0;
 		}
 
 		if (utf8strlen) {
-			drw_font_getexts(curfont, utf8str, utf8strlen, &tex);
+			drw_font_getexts(usedfont, utf8str, utf8strlen, &ew, NULL);
 			/* shorten text if necessary */
-			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - drw->fonts[0]->h || w < drw->fonts[0]->h); len--)
-				drw_font_getexts(curfont, utf8str, len, &tex);
+			for (len = MIN(utf8strlen, sizeof(buf) - 1); len && ew > w; len--)
+				drw_font_getexts(usedfont, utf8str, len, &ew, NULL);
 
 			if (len) {
 				memcpy(buf, utf8str, len);
 				buf[len] = '\0';
 				if (len < utf8strlen)
-					for (i = len; i && i > len - 3; buf[--i] = '.');
+					for (i = len; i && i > len - 3; buf[--i] = '.')
+						; /* NOP */
 
 				if (render) {
-					th = curfont->ascent + curfont->descent;
-					ty = y + (h / 2) - (th / 2) + curfont->ascent;
-					tx = x + (h / 2);
-					XftDrawStringUtf8(d, invert ? &drw->scheme->bg->rgb : &drw->scheme->fg->rgb, curfont->xfont, tx, ty, (XftChar8 *)buf, len);
+					ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
+					XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
+					                  usedfont->xfont, x, ty, (XftChar8 *)buf, len);
 				}
-				x += tex.w;
-				w -= tex.w;
+				x += ew;
+				w -= ew;
 			}
 		}
 
@@ -303,26 +320,21 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 			break;
 		} else if (nextfont) {
 			charexists = 0;
-			curfont = nextfont;
+			usedfont = nextfont;
 		} else {
 			/* Regardless of whether or not a fallback font is found, the
-			 * character must be drawn.
-			 */
+			 * character must be drawn. */
 			charexists = 1;
 
-			if (drw->fontcount >= DRW_FONT_CACHE_SIZE)
-				continue;
-
 			fccharset = FcCharSetCreate();
 			FcCharSetAddChar(fccharset, utf8codepoint);
 
-			if (!drw->fonts[0]->pattern) {
-				/* Refer to the comment in drw_font_xcreate for more
-				 * information. */
+			if (!drw->fonts->pattern) {
+				/* Refer to the comment in xfont_create for more information. */
 				die("the first font in the cache must be loaded from a font string.\n");
 			}
 
-			fcpattern = FcPatternDuplicate(drw->fonts[0]->pattern);
+			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
 			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
 			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
 
@@ -334,12 +346,14 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 			FcPatternDestroy(fcpattern);
 
 			if (match) {
-				curfont = drw_font_xcreate(drw, NULL, match);
-				if (curfont && XftCharExists(drw->dpy, curfont->xfont, utf8codepoint)) {
-					drw->fonts[drw->fontcount++] = curfont;
+				usedfont = xfont_create(drw, NULL, match);
+				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
+					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
+						; /* NOP */
+					curfont->next = usedfont;
 				} else {
-					drw_font_free(curfont);
-					curfont = drw->fonts[0];
+					xfont_free(usedfont);
+					usedfont = drw->fonts;
 				}
 			}
 		}
@@ -347,34 +361,40 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 	if (d)
 		XftDrawDestroy(d);
 
-	return x;
+	return x + (render ? w : 0);
 }
 
 void
 drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 {
+	if (!drw)
+		return;
+
 	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
 	XSync(drw->dpy, False);
 }
 
-void
-drw_font_getexts(Fnt *font, const char *text, unsigned int len, Extnts *tex)
+unsigned int
+drw_fontset_getwidth(Drw *drw, const char *text)
 {
-	XGlyphInfo ext;
-
-	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-	tex->h = font->h;
-	tex->w = ext.xOff;
+	if (!drw || !drw->fonts || !text)
+		return 0;
+	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
 }
 
-unsigned int
-drw_font_getexts_width(Fnt *font, const char *text, unsigned int len)
+void
+drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
 {
-	Extnts tex;
+	XGlyphInfo ext;
 
-	drw_font_getexts(font, text, len, &tex);
+	if (!font || !text)
+		return;
 
-	return tex.w;
+	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
+	if (w)
+		*w = ext.xOff;
+	if (h)
+		*h = font->h;
 }
 
 Cur *
@@ -382,7 +402,9 @@ drw_cur_create(Drw *drw, int shape)
 {
 	Cur *cur;
 
-	cur = ecalloc(1, sizeof(Cur));
+	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
+		return NULL;
+
 	cur->cursor = XCreateFontCursor(drw->dpy, shape);
 
 	return cur;
@@ -393,6 +415,7 @@ drw_cur_free(Drw *drw, Cur *cursor)
 {
 	if (!cursor)
 		return;
+
 	XFreeCursor(drw->dpy, cursor->cursor);
 	free(cursor);
 }
diff --git a/drw.h b/drw.h
index e3b8515..ff4355b 100644
--- a/drw.h
+++ b/drw.h
@@ -1,29 +1,19 @@
 /* See LICENSE file for copyright and license details. */
-#define DRW_FONT_CACHE_SIZE 32
-
-typedef struct {
-	unsigned long pix;
-	XftColor rgb;
-} Clr;
 
 typedef struct {
 	Cursor cursor;
 } Cur;
 
-typedef struct {
+typedef struct Fnt {
 	Display *dpy;
-	int ascent;
-	int descent;
 	unsigned int h;
 	XftFont *xfont;
 	FcPattern *pattern;
+	struct Fnt *next;
 } Fnt;
 
-typedef struct {
-	Clr *fg;
-	Clr *bg;
-	Clr *border;
-} ClrScheme;
+enum { ColFg, ColBg, ColCount }; /* Scm index */
+typedef XftColor *Scm;
 
 typedef struct {
 	unsigned int w, h;
@@ -32,43 +22,36 @@ typedef struct {
 	Window root;
 	Drawable drawable;
 	GC gc;
-	ClrScheme *scheme;
-	size_t fontcount;
-	Fnt *fonts[DRW_FONT_CACHE_SIZE];
+	Scm scheme;
+	Fnt *fonts;
 } Drw;
 
-typedef struct {
-	unsigned int w;
-	unsigned int h;
-} Extnts;
-
 /* Drawable abstraction */
-Drw *drw_create(Display *, int, Window, unsigned int, unsigned int);
-void drw_resize(Drw *, unsigned int, unsigned int);
-void drw_free(Drw *);
+Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
+void drw_resize(Drw *drw, unsigned int w, unsigned int h);
+void drw_free(Drw *drw);
 
 /* Fnt abstraction */
-Fnt *drw_font_create(Drw *, const char *);
-void drw_load_fonts(Drw *, const char *[], size_t);
-void drw_font_free(Fnt *);
-void drw_font_getexts(Fnt *, const char *, unsigned int, Extnts *);
-unsigned int drw_font_getexts_width(Fnt *, const char *, unsigned int);
+Fnt *drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount);
+void drw_fontset_free(Fnt* set);
+unsigned int drw_fontset_getwidth(Drw *drw, const char *text);
+void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
 
-/* Colour abstraction */
-Clr *drw_clr_create(Drw *, const char *);
-void drw_clr_free(Clr *);
+/* Colorscheme abstraction */
+void drw_clr_create(Drw *drw, XftColor *dest, const char *clrname);
+Scm drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
 
 /* Cursor abstraction */
-Cur *drw_cur_create(Drw *, int);
-void drw_cur_free(Drw *, Cur *);
+Cur *drw_cur_create(Drw *drw, int shape);
+void drw_cur_free(Drw *drw, Cur *cursor);
 
 /* Drawing context manipulation */
-void drw_setfont(Drw *, Fnt *);
-void drw_setscheme(Drw *, ClrScheme *);
+void drw_setfontset(Drw *drw, Fnt *set);
+void drw_setscheme(Drw *drw, Scm scm);
 
 /* Drawing functions */
-void drw_rect(Drw *, int, int, unsigned int, unsigned int, int, int, int);
-int drw_text(Drw *, int, int, unsigned int, unsigned int, const char *, int);
+void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
+int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
 
 /* Map functions */
-void drw_map(Drw *, Window, int, int, unsigned int, unsigned int);
+void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
diff --git a/dwm.c b/dwm.c
index 9585683..b2bc9bd 100644
--- a/dwm.c
+++ b/dwm.c
@@ -55,7 +55,8 @@
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_text(drw, 0, 0, 0, 0, (X), 0) + drw->fonts[0]->h)
+#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+#define ColBorder               2
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
@@ -240,6 +241,7 @@ static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
+static int lrpad;            /* sum of left and right padding for text */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
@@ -261,7 +263,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static int running = 1;
 static Cur *cursor[CurLast];
-static ClrScheme scheme[SchemeLast];
+static Scm scheme[SchemeLast];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -481,11 +483,8 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < SchemeLast; i++) {
-		drw_clr_free(scheme[i].border);
-		drw_clr_free(scheme[i].bg);
-		drw_clr_free(scheme[i].fg);
-	}
+	for (i = 0; i < SchemeLast; i++)
+		free(scheme[i]);
 	drw_free(drw);
 	XSync(dpy, False);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
@@ -709,11 +708,18 @@ dirtomon(int dir)
 void
 drawbar(Monitor *m)
 {
-	int x, xx, w, dx;
+	int x, w, sw = 0;
+	int boxs = drw->fonts->h / 9;
+	int boxw = drw->fonts->h / 6 + 2;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
-	dx = (drw->fonts[0]->ascent + drw->fonts[0]->descent + 2) / 4;
+	/* draw status first so it can be overdrawn by tags later */
+	if (m == selmon) { /* status is only drawn on selected monitor */
+		drw_setscheme(drw, scheme[SchemeNorm]);
+		sw = TEXTW(stext) - lrpad / 2; /* no right padding so status text hugs the corner */
+		drw_text(drw, m->ww - sw, 0, sw, bh, lrpad / 2 - 2, stext, 0);
+	}
 
 	for (c = m->clients; c; c = c->next) {
 		occ |= c->tags;
@@ -723,36 +729,27 @@ drawbar(Monitor *m)
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
-		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
-		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-		           occ & 1 << i, urg & 1 << i);
+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+		if (occ & 1 << i)
+			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+			         m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+			         urg & 1 << i);
 		x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, &scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
-	x += w;
-	xx = x;
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		w = TEXTW(stext);
-		x = m->ww - w;
-		if (x < xx) {
-			x = xx;
-			w = m->ww - xx;
-		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
-	} else
-		x = m->ww;
-	if ((w = x - xx) > bh) {
-		x = xx;
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+
+	if ((w = m->ww - sw - x) > bh) {
 		if (m->sel) {
-			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
-			drw_rect(drw, x + 1, 1, dx, dx, m->sel->isfixed, m->sel->isfloating, 0);
+			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+			if (m->sel->isfloating)
+				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
 		} else {
-			drw_setscheme(drw, &scheme[SchemeNorm]);
-			drw_rect(drw, x, 0, w, bh, 1, 0, 1);
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_rect(drw, x, 0, w, bh, 1, 1);
 		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
@@ -812,7 +809,7 @@ focus(Client *c)
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel].border->pix);
+		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
 		setfocus(c);
 	} else {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
@@ -1071,7 +1068,7 @@ manage(Window w, XWindowAttributes *wa)
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1563,10 +1560,10 @@ setup(void)
 	sh = DisplayHeight(dpy, screen);
 	root = RootWindow(dpy, screen);
 	drw = drw_create(dpy, screen, root, sw, sh);
-	drw_load_fonts(drw, fonts, LENGTH(fonts));
-	if (!drw->fontcount)
+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
 		die("no fonts could be loaded.\n");
-	bh = drw->fonts[0]->h + 2;
+	lrpad = drw->fonts->h;
+	bh = drw->fonts->h + 2;
 	updategeom();
 	/* init atoms */
 	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
@@ -1586,12 +1583,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme[SchemeNorm].border = drw_clr_create(drw, normbordercolor);
-	scheme[SchemeNorm].bg = drw_clr_create(drw, normbgcolor);
-	scheme[SchemeNorm].fg = drw_clr_create(drw, normfgcolor);
-	scheme[SchemeSel].border = drw_clr_create(drw, selbordercolor);
-	scheme[SchemeSel].bg = drw_clr_create(drw, selbgcolor);
-	scheme[SchemeSel].fg = drw_clr_create(drw, selfgcolor);
+	scheme[SchemeNorm] = drw_scm_create(drw, colors[SchemeNorm], 3);
+	scheme[SchemeSel] = drw_scm_create(drw, colors[SchemeSel], 3);
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1751,7 +1744,7 @@ unfocus(Client *c, int setfocus)
 	if (!c)
 		return;
 	grabbuttons(c, 0);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
 	if (setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
diff --git a/util.h b/util.h
index cded043..f633b51 100644
--- a/util.h
+++ b/util.h
@@ -4,5 +4,5 @@
 #define MIN(A, B)               ((A) < (B) ? (A) : (B))
 #define BETWEEN(X, A, B)        ((A) <= (X) && (X) <= (B))
 
-void die(const char *errstr, ...);
-void *ecalloc(size_t, size_t);
+void die(const char *fmt, ...);
+void *ecalloc(size_t nmemb, size_t size);
--
cgit v0.9.0.3-65-g4555
